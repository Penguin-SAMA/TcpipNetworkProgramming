# 第一章 理解编程和套接字

## 1.1 理解编程和套接字

### 1.1.1 网络编程和套接字概要

套接字是网络数据传输用的软件设备。

编程中的“套接字”就是用来连接该网络的工具。

### 1.1.2 构建电话套接字

#### 调用 socket 函数时进行的对话

```c
#include <sys/socket.h>

int socket(int domian, int type, int protocol);
//成功时返回文件描述符，失败时返回-1
```

#### 调用 bind 函数时进行的对话

```c
#include <syd/socket.h>

int bind(int sockfd, struct sockaddr *myaddr, socklen_t addrlen);
//成功时返回0，失败时返回-1
```

#### 调用 listen 函数时进行的对话

```c
#include <sys/socket.h>

int listen(int sockfd, int backlog);
//成功时返回0，失败时返回-1
```

#### 调用 accept 函数时进行的对话

```c
#include <sys/socket.h>

int accpet(int sockfd, struct sockaddr *addr, socklen_t *addrlen);
//成功时返回文件描述符，失败时返回-1
```

网络编程中接受连接请求的套接字创建过程如下:

<<<<<<< HEAD
- 调用 socket 函数创建套接字
- 调用 bind 函数分配 IP 地址和端口号
- 调用 listen 函数转为可接受请求状态
- 调用 accept 函数转为可接受请求状态
=======
- 调用socket函数创建套接字
- 调用bind函数分配IP地址和端口号
- 调用listen函数转为可接受请求状态
- 调用accept函数转为可接受请求状态

## 1.2 基于Linux的文件操作

对Linux而言，socket操作与文件操作没有区别。

在Linux世界里，socket也被认为是文件的一种，因此在网络数据传输过程中自然可以使用文件I/O的相关函数。

### 1.2.1 底层文件访问和文件描述符

"底层"：与标准无关的操作系统独立提供的。

如果想使用Linux提供的文件I/O函数，首先应该理解好文件描述符的概念。

文件和套接字一般经过创建过程才会被分配文件描述符。

### 1.2.2 打开文件

```c
#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>

//path			文件名的字符串信息
//flag			文件打开模式信息
int open(const char *path, int flag);
//成功时返回文件描述符，失败时返回-1
```

### 1.2.3 关闭文件

```c
#include <unistd.h>

//fd			需要关闭的文件或套接字的文件描述符
int close(int fd);
//成功时返回0，失败时返回-1
```

若调用此函数的同时传递文件描述符参数，则关闭相应文件。

此函数不仅可以关闭文件，还可以关闭套接字。

### 1.2.4 将数据写入文件

```c
#include <unistd.h>

//fd			显示数据传输对象的文件描述符
//buf			保存要传输数据的缓冲地址值
//nbytes		要传输数据的字节数
ssize_t write(int fd, const void * buf, size_t nbytes);
//成功时返回写入的字节数，失败时返回-1
```

其中`ssize_t`是通过typedef声明的`unsigned int`类型。

### 1.2.5 读取文件中的数据

```cpp
#include <unistd.h>

//fd			显示数据接收对象的文件描述符
//buf			要保存接收数据的缓冲地址值
//nbytes		要接受数据的最大字节数
ssize_t read(int fd, void *buf, size_t nbytes);
//成功时返回接收的字节数(如果遇到文件结尾返回0)，失败时返回-1
```

# 第二章 套接字类型与协议设置

## 2.1 套接字协议及其数据传输特性

### 2.1.1 关于协议

协议是对话中使用的通信规则，拓展到计算机领域可称为"计算机间对话必备通信规则"。

### 2.1.2 创建套接字

```c
#include <sys/socket.h>

//domain		套接字中使用的协议族信息
//type			套接字数据传输类型信息
//protocol		计算机间通信中使用的协议信息
int socket(int domain, int type, int protocol);
//成功时返回文件描述符，失败时返回-1
```

### 2.1.3 协议族

| 名称      | 协议族               |
| --------- | -------------------- |
| PF_INET   | IPv4互联网协议族     |
| PF_INET6  | IPv6互联网协议族     |
| PF_LOCAL  | 本地通信的UNIX协议族 |
| PF_PACKET | 底层套接字的协议族   |
| PF_IPX    | IPX Novell协议族     |

### 2.1.4 套接字类型

套接字类型指的是套接字的数据传输方式，通过socket函数的第二个参数传递，只有这样才能决定创建的套接字的数据传输方式。

### 2.1.5 面向连接的套接字SOCK_STREAM

面向连接的特征：

- 传输过程中数据不会消失。
- 按序传输数据。
- 传输的数据不存在数据边界。

收发数组的套接字内部有缓冲，简而言之就是字节数组。

> 可靠的、按序传输的、基于字节的面向连接的数据传输方式的套接字。

### 2.1.6 面向消息的套接字SOCK_DGRAM

面向消息的特征：

- 强调快速传输而非传输顺序。
- 传输的数据可能丢失也可能损毁。
- 传输的数据有数据边界。
- 限制每次传输的数据大小。

> 不可靠的、不按序传递的、以数据的高速传输为目的的套接字。

### 2.1.7 协议的最终选择

socket函数的第三个参数决定最终采用的协议。

大部分情况下可以向第三个参数传递0，除非同一协议族中存在多个数据传输方式相同的协议。

### 2.1.8 TCP套接字示例

更改hello_client.c文件中的read函数的调用次数。

在客户端中分多次调用read函数以接受服务器端发送的全部数据。

# 第3章 地址族与数据序列

## 3.1 分配给套接字的IP地址与端口号

IP是Internet Protocol的简写，是为收发网络数据而分配给计算机的值。

端口号并非赋予计算机的值，而是为区分程序中创建的套接字而分配给套接字的序号。

### 3.1.1 网络地址

为使计算机连接到网络并收发数据，必须向其分配IP地址。

IP地址分为两类：

- IPv4	4字节地址族
- IPv6   16字节地址族

### 3.1.2 网络地址分类与主机地址边界

只需通过IP地址的第一个字节即可判断网络地址占用的字节数：

- A类地址的首字节范围：0～127
- B类地址的首字节范围：128～191
- C类地址的首字节范围：192～223

另一种表述方式：

- A类地址的首位以0开始
- B类地址的前两位以10开始
- C类地址的前三位以110开始
